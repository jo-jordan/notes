
# Java内存模型
## 起源

## JSR 133

## 指令重排
编译器重排；
CPU寄存器、CPU缓存、内存读写顺序的重排；

## 什么是不正确的同步程序？
这个问题我们限定在Java内存模型内容范围内，现有如下情形：
1. 一个线程读取一个变量的值，
2. 另一个线程写值到这个相同的变量中
3. 读写的顺序是没有被同步排列的

当这些规则被打破，那么变量就会出现*数据竞争*，一个有数据竞争问题的程序就是不正确的同步程序

## 什么是数据竞争(Data Race)
数据竞争发生在
- 一个进程中的多个线程同时访问同一块内存
- 其中至少有一个线程是写操作
- 所有线程均没有使用任何排他锁来控制其对内存的访问

当这些条件被满足时，访问顺序是不确定的，并且计算结果完全取决于每个线程运行的先后顺序，这时，数据竞争就开始了（比如，当内存的访问用于繁忙等待时），但是很多数据竞争是程序中的bug。

## 同步干了什么？
同步有很多个层面，但广为人知的还是“相互排斥(mutual exclusion)”——一次只有一个线程能够立即持有一个monitor，monitor上的同步也就意味着，当有一个线程进入这个被monitor保护的同步代码块(synchronized block)时，是不会有其他线程能够进入的，直到第一个线程退出了这个同步代码块。

但这里也有比相互排斥更加深层次的理解。同步确保了使用一些可预见性的方法让一块内存被读写前或者期间是对其他在同一个monitor下线程是可见的。当我们退出了同步代码块，我们释放monitor，这个操作会起到刷新主内存中的作用，所以这个线程的写操作会对其他线程可见。在我们进入同步代码之前，我们获取到monitor，这里会起到使得本地处理器中的缓存的值失效的作用，因此会促使这个值会被从主内存中重新加载。然后我们就能够可见任何在前一次释放后的写入的值

> - 当执行完毕同步代码后，释放monitor，把计算的结果从cache刷新到主内存
> - 当进入同步代码时，获取monitor，让cache失效，并将主内存中的值重载到cache中
> 
> 以上两步我理解为，如果服务看作是cache，数据库是主内存，服务的开始计算前，总是从数据库中获取一次最新值，服务计算结束后，总是会把计算结果刷新到数据库。

在缓存的术语中讨论这些，听起来就好像这些情形只发生在多处理器的机器中。但其实，指令重排的效果在单核处理器中更加容易被发现。比如说，对于一个编译器来说，移动你的代码到获取之前或者到释放之后是不可能的。当我们说在cache中发生获取和释放操作时，我们会为一系列可能的效果使用速记法。

新的内存模型语义在内存操作上(读字段、写字段、锁定、解锁)以及线程操作上(start、join)创建了部分排序，这些操作被认为是*发生在其他操作之前*(*happen brefore*)。当一个操作发生在另一个之前，第一个操作的顺序以及会被保证在第二个操作前发生，以及对于第二个操作是可见的。以下是排序的规则：
- 线程中的每个操作是在这个程序中顺序列表中即将被执行的每个操作之前发生的。
- 每个相同monitor的解锁发生在每个随后的锁定之前。
- 每个相同volatile变量的写入发生在每个随后的读取之前。
- 调用一个线程的start()发生在已经开始的线程任何操作之前。
- 一个线程中的所有操作都发生在其他线程成功从该线程的join()返回之前。

这也就意味着，被同一个monitor保护的同步块中，对于一个线程来说，在退出同步块之前以及进入同步块之后，所有内存操作是可见的，也就是说，所有内存操作都发生在释放前，所有释放操作都发生在获取之前。

另外一个需要指出的是，在下面的例子中，也是大多数人用来强制作为内存壁垒的语句，它是没用的：

```java
synchronized { new Object(); }
```

这实际上是一个空操作，你的编译器可以将其整个干掉，因为编译器会认为在同一个monitor下，其他线程这个操作是不同步的。为了能使结果对其他线程可见，你必须为每个线程都建立一个*happens-before*关系。

**重要提示：**为每个线程都建立一个*happens-before*关系是极其重要的。这并不是说，在对象X上同步的线程A在对象Y上同步之后对线程B是可见的。释放和获取在正确的语义上必须是配套的（在同一个monitor上），否则代码就是数据竞争。

## final字段是如何显示其更改了他的值？
其中一个最好的实例来展示final字段是如何更改其值的，需要说到``` String```类的实现。

一个String的实现能够被看作是由三个字段——一个是字符数组，一个是数组的偏移量，一个是长度，组成的对象，String的如此实现，并非是让其仅拥有一个字符数组的根本原因，是它让多个String和StringBuffer对象分享相同的字符对象和避免多余的对象分配和复制。因此，举个例子，```String.substring()```方法能够被创建一个新的字符串数组而实现，而这个新的字符串会与原来的String对象共享同一个字符数组，而仅有不同的字段只是偏移量和长度。对于一个String来说，这些都是final字段：
```java
String s1 = "/usr/tmp";
String s2 = s1.substring(4);
```

字符串s2将会是偏移量为4，长度为4。但是在老的模型下，是有可能现看到偏移量、长度默认为0，后面才会看见正确的数值4，这表现得就好像字符串"/usr"变成了"/tmp"。

原来的JMM是允许这个行为的，少许的JVM展示了这个行为，新的JMM将其列为非法。

## final字段如何在新JMM下工作？
final变量会在对象的构造器中被赋值。假设一个对象被“正确”构造，一旦对象被构造，在构造中的final字段会被其他所有不同步的线程可见。
